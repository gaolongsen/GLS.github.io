<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Robust MPC Learning Note | Longsen Gao </title> <meta name="author" content="Longsen Gao"> <meta name="description" content="Learning note for robust MPC"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://gaolongsen.github.io/blog/2024/note1/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Longsen</span> Gao </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Robust MPC Learning Note</h1> <p class="post-meta"> Created in May 10, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/mpc"> <i class="fa-solid fa-hashtag fa-sm"></i> MPC</a>     ·   <a href="/blog/category/sample-posts"> <i class="fa-solid fa-tag fa-sm"></i> sample-posts</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <hr> <p>This learning note is based on the paper <code class="language-plaintext highlighter-rouge">"Lorenzen, Matthias, Mark Cannon, and Frank Allgöwer. "Robust MPC with recursive model update." *Automatica* 103 (2019): 461-471."</code></p> <hr> <h2 id="receding-horizon-control-rhc-algorithm">Receding Horizon Control (RHC) Algorithm</h2> <p>Receding Horizon Control (RHC), also known as Model Predictive Control (MPC), is a popular control strategy in which the current control action is obtained by solving an open-loop optimal control problem at each time step. This approach involves predicting the future behavior of the system over a finite horizon and optimizing the control inputs accordingly.</p> <h3 id="key-components">Key Components</h3> <ol> <li> <strong>Prediction Model</strong>: A mathematical model of the system dynamics used to predict future states based on current states and control inputs.</li> <li> <strong>Prediction Horizon</strong>: A finite time window over which future states and control inputs are optimized.</li> <li> <strong>Cost Function</strong>: An objective function that quantifies the performance of the system over the prediction horizon, typically involving terms for tracking error, control effort, and possibly state and input constraints.</li> <li> <strong>Constraints</strong>: Physical or operational constraints on the states and control inputs, such as actuator limits or safety requirements.</li> </ol> <h3 id="algorithm-steps">Algorithm Steps</h3> <ol> <li> <p><strong>Measure or Estimate the Current State</strong>: Obtain the current state of the system \(x_k\).</p> </li> <li> <p><strong>Solve the Optimization Problem</strong>:</p> <ul> <li> <p>Formulate an optimization problem over a finite prediction horizon $ N $. This involves predicting future states \(x_{k+1}, x_{k+2}, \ldots, x_{k+N}\) and corresponding control inputs \(u_k, u_{k+1}, \ldots, u_{k+N-1}\).</p> </li> <li> <p>The objective is to minimize a cost function \(J\) that typically takes the form: \(\sum_{i=k}^{k+N-1} \left( \| x_i - x_{\text{ref}} \|_Q^2 + \| u_i \|_R^2 \right)\) where \(x_{\text{ref}}\) is the reference state, and \(Q\) and \(R\) are weighting matrices.</p> </li> <li> <p>Subject to the system dynamics:</p> <p>\(x_{i+1} = f(x_i, u_i)\) and any state and input constraints:</p> \[x_i \in \mathcal{X}, \quad u_i \in \mathcal{U}\] </li> </ul> </li> <li> <p><strong>Apply the First Control Input</strong>:</p> <ul> <li>Implement the first control input \(u_k^*\) obtained from the optimization problem.</li> </ul> </li> <li> <p><strong>Recede the Horizon</strong>:</p> <ul> <li>Move the time index forward by one step, i.e., (\(k \to k+1\)).</li> <li>Repeat the process from step 1 with updated state information.</li> </ul> </li> </ol> <h3 id="benefits">Benefits</h3> <ul> <li> <strong>Optimal Performance</strong>: By solving an optimization problem at each time step, RHC can achieve near-optimal control performance.</li> <li> <strong>Explicit Handling of Constraints</strong>: Constraints on states and inputs can be directly incorporated into the optimization problem, ensuring that the control actions respect these constraints.</li> <li> <strong>Adaptability</strong>: The approach can adapt to changes in the system dynamics or the environment, as it recalculates the control actions at each time step.</li> </ul> <h3 id="example">Example</h3> <p>Consider a simple linear system:</p> \[x_{k+1} = A x_k + B u_k\] <p>with state \(x\) and control input \(u\). The goal is to track a reference trajectory \(x_{\text{ref}}\).</p> <ol> <li> <p><strong>Prediction Model</strong>: Use the system dynamics to predict future states.</p> </li> <li> <p><strong>Cost Function</strong>: Minimize a cost function over a prediction horizon \(N\):</p> </li> </ol> \[\sum_{i=k}^{k+N-1} \left( (x_i - x_{\text{ref}})^T Q (x_i - x_{\text{ref}}) + u_i^T R u_i \right)\] <ol> <li> <p><strong>Solve Optimization</strong>: Solve for \(u_k, \ldots, u_{k+N-1}\) subject to the constraints.</p> </li> <li> <p><strong>Apply Control</strong>: Implement the first control input \(u_k\).</p> </li> <li> <p><strong>Recede Horizon</strong>: Move to the next time step and repeat the process.</p> </li> </ol> <h3 id="conclusion">Conclusion</h3> <p>Receding Horizon Control is a powerful control strategy that leverages optimization techniques to achieve optimal control performance while explicitly handling constraints. Its ability to adapt to changing conditions and ensure constraint satisfaction makes it suitable for various applications, including robotics, process control, and automotive systems.</p> <hr> <h3 id="set-membership-estimation">Set-Membership Estimation</h3> <p>Set-membership estimation is an approach used in control theory and system identification to estimate the state or parameters of a system when the measurements are known to belong to a certain set. Unlike traditional methods that rely on probabilistic models and noise assumptions, set-membership estimation works with bounded uncertainties and provides guaranteed bounds on the estimation errors.</p> <h3 id="key-concepts">Key Concepts</h3> <ol> <li> <strong>Uncertain Models</strong>: Systems where the exact model parameters are unknown but bounded within certain sets.</li> <li> <strong>Bounding Sets</strong>: Sets containing all possible uncertainties, disturbances, or noise values.</li> <li> <strong>Feasible Set</strong>: The set of all parameter or state values that are consistent with the given measurements and their bounds.</li> </ol> <h3 id="mathematical-formulation">Mathematical Formulation</h3> <p>Consider a system described by:</p> \[y(t) = f(x(t), u(t), \theta) + v(t)\] <p>where:</p> <ul> <li>\(y(t)\) is the output.</li> <li>\(x(t)\) is the state vector.</li> <li>\(u(t)\) is the input vector.</li> <li>\(\theta\) is the parameter vector.</li> <li>\(v(t)\) represents the measurement noise or disturbance, which is bounded.</li> </ul> <p>In set-membership estimation, we assume that the noise $v(t)$ belongs to a known bounded set $V$, typically described as:</p> \[v(t) \in V = \{ v \in \mathbb{R}^m \mid \| v \| \leq \delta \}\] <p>where $ \delta $ is a known bound on the noise.</p> <h3 id="estimation-process">Estimation Process</h3> <ol> <li> <strong>Initial Feasible Set</strong>: Start with an initial feasible set for the parameters or states, \(\Theta_0\).</li> <li> <strong>Update Feasible Set</strong>: For each new measurement \(y(t)\), update the feasible set by intersecting the current feasible set with the set of values consistent with the new measurement and its bound.</li> <li> <strong>Recursive Update</strong>: Continue updating the feasible set as new measurements become available.</li> </ol> <h3 id="example-1">Example</h3> <p>Suppose we have a simple linear system:</p> \[y(t) = \theta u(t) + v(t)\] <table> <tbody> <tr> <td>where \(\theta\) is an unknown parameter to be estimated, and \(v(t)\) is the noise bounded by $$</td> <td>v(t)</td> <td>\leq \delta$$.</td> </tr> </tbody> </table> <ol> <li> <p><strong>Initial Feasible Set</strong>: Assume an initial bound for the parameter \(\theta\):</p> \[\Theta_0 = [\theta_{\min}, \theta_{\max}]\] </li> <li> <p><strong>Measurement Update</strong>: For a given input \(u(t)\) and measurement \(y(t)\), the feasible set for \(\theta\) is:</p> \[\Theta_t = \{ \theta \in \Theta_{t-1} \mid y(t) - \delta \leq \theta u(t) \leq y(t) + \delta \}\] </li> <li> <p><strong>Recursive Update</strong>: For each new measurement, update the feasible set:</p> \[\Theta_{t+1} = \Theta_t \cap \{ \theta \in \mathbb{R} \mid y(t+1) - \delta \leq \theta u(t+1) \leq y(t+1) + \delta \}\] </li> </ol> <h3 id="benefits-1">Benefits</h3> <ol> <li> <strong>Guaranteed Bounds</strong>: Provides guaranteed bounds on the estimation error.</li> <li> <strong>Robustness</strong>: Effective in scenarios with bounded but unknown disturbances or noise.</li> <li> <strong>Non-Probabilistic</strong>: Does not require probabilistic assumptions about noise or disturbances.</li> </ol> <h3 id="applications">Applications</h3> <ol> <li> <strong>Fault Detection and Isolation</strong>: Identifying faults in systems where uncertainties are bounded.</li> <li> <strong>Robust Control</strong>: Designing controllers that can handle bounded uncertainties.</li> <li> <strong>System Identification</strong>: Estimating parameters of systems with bounded noise.</li> </ol> <h3 id="conclusion-1">Conclusion</h3> <p>Set-membership estimation is a robust technique for estimating the state or parameters of a system in the presence of bounded uncertainties. By working with sets and ensuring that all feasible solutions are considered, this approach provides guaranteed bounds on the estimation errors and is particularly useful in applications where probabilistic noise models are not appropriate.</p> <hr> <p>For <strong>Eq.(12)</strong> to <strong>Eq.(13)</strong> explains the recursive update of a parameter estimate \(\hat{\theta}_k\) in a set-membership estimation context. Let’s break down each part in detail.</p> <h4 id="predicted-state-and-prediction-error">Predicted State and Prediction Error</h4> <ol> <li> <table> <tbody> <tr> <td>**Predicted State $$\hat{x}_{1</td> <td>k}$$**:</td> </tr> </tbody> </table> \[\hat{x}_{1|k} = A(\hat{\theta}_k)x_k + B(\hat{\theta}_k)u_k\] <ul> <li>This represents the predicted state at the next time step (\(k+1\)) given the current parameter estimate \(\hat{\theta}_k\).</li> <li>\(A(\hat{\theta}_k)\) and \(B(\hat{\theta}_k)\) are matrices dependent on the parameter estimate \(\hat{\theta}_k\).</li> <li>\(x_k\) is the current state, and \(u_k\) is the current control input.</li> </ul> </li> <li> <table> <tbody> <tr> <td>**Prediction Error $$\tilde{x}_{1</td> <td>k}$$**:</td> </tr> </tbody> </table> \[\tilde{x}_{1|k} = A(\theta^*)x_k + B(\theta^*)u_k - \hat{x}_{1|k}\] <ul> <li> <table> <tbody> <tr> <td>$$\tilde{x}_{1</td> <td>k}\(is the error between the true next state (using the true parameter\)\theta^*\() and the predicted state (using the estimated parameter\)\hat{\theta}_k$$).</td> </tr> </tbody> </table> </li> <li>\(\theta^*\) is the true parameter vector.</li> </ul> </li> </ol> <h4 id="parameter-update-rule">Parameter Update Rule</h4> <ol> <li> <p><strong>Update Rule</strong>:</p> \[\hat{\theta}_k = \hat{\theta}_{k-1} + \mu D(x_{k-1}, u_{k-1})^\top (x_k - \hat{x}_{1|k-1})\] <ul> <li>\(\hat{\theta}_k\) is the updated parameter estimate at time \(k\).</li> <li>\(\hat{\theta}_{k-1}\) is the parameter estimate from the previous time step (\(k-1\)).</li> <li>\(\mu \in \mathbb{R}_{&gt;0}\) is a positive scalar gain for the parameter update.</li> <li>\(D(x_{k-1}, u_{k-1})\) is a matrix or function derived from the state \(x_{k-1}\) and input \(u_{k-1}\). It represents the sensitivity or derivative of the system dynamics with respect to the parameters.</li> <li> <table> <tbody> <tr> <td>$$x_k - \hat{x}_{1</td> <td>k-1}\(is the prediction error at time\)k\(using the estimate from time\)k-1$$.</td> </tr> </tbody> </table> </li> </ul> </li> <li> <p><strong>Projection onto the Parameter Set</strong>:</p> \[\hat{\theta}_k = \Pi_{\Theta}(\tilde{\theta}_k)\] <ul> <li>\(\tilde{\theta}_k\) is the intermediate parameter estimate after applying the update rule.</li> <li>\(\Pi_{\Theta}(\tilde{\theta}_k)\) denotes the projection of \(\tilde{\theta}_k\) onto the parameter set \(\Theta\).</li> <li> <p>The projection ensures that the parameter estimate \(\hat{\theta}_k\) remains within the feasible set \(\Theta\), which is defined as:</p> \[\Pi_{\Theta}(\tilde{\theta}) = \arg\min_{\theta \in \Theta} \|\theta - \tilde{\theta}\|\] <p>This represents the point in \(\Theta\) closest to \(\tilde{\theta}\) in the Euclidean sense.</p> </li> </ul> </li> </ol> <h3 id="detailed-steps">Detailed Steps</h3> <ol> <li> <strong>Prediction</strong>: <ul> <li> <table> <tbody> <tr> <td>Calculate the predicted state $$\hat{x}_{1</td> <td>k}\(using the current parameter estimate\)\hat{\theta}_k$$.</td> </tr> </tbody> </table> </li> <li> <table> <tbody> <tr> <td>Compute the prediction error $$\tilde{x}_{1</td> <td>k}\(based on the true parameter\)\theta^*$$.</td> </tr> </tbody> </table> </li> </ul> </li> <li> <strong>Update</strong>: <ul> <li>Update the parameter estimate \(\hat{\theta}_{k-1}\) using the prediction error and the sensitivity matrix \(D(x_{k-1}, u_{k-1})\).</li> <li> <table> <tbody> <tr> <td>The term $$\mu D(x_{k-1}, u_{k-1})^\top (x_k - \hat{x}_{1</td> <td>k-1})$$ adjusts the parameter estimate in the direction that reduces the prediction error.</td> </tr> </tbody> </table> </li> </ul> </li> <li> <strong>Projection</strong>: <ul> <li>Ensure the updated parameter estimate \(\hat{\theta}_k\) stays within the feasible set \(\Theta\) by projecting \(\tilde{\theta}_k\) onto \(\Theta\).</li> </ul> </li> </ol> <h3 id="conditions">Conditions</h3> <p>The update gain \(\mu\) must satisfy the condition:</p> \[\frac{1}{\mu} &gt; \sup_{(x,u) \in \mathcal{Z}} \|D(x,u)\|^2\] <ul> <li>This condition ensures that the update step does not diverge and remains stable.</li> <li>\(\mathcal{Z}\) represents the set of all possible states and inputs.</li> </ul> <h3 id="summary">Summary</h3> <p>The given mathematical expressions describe a recursive parameter estimation algorithm that iteratively updates the parameter estimate \(\hat{\theta}_k\) based on the prediction error while ensuring that the estimate remains within a feasible set \(\Theta\). The key steps involve predicting the next state, computing the prediction error, updating the parameter estimate, and projecting it back onto the feasible set to maintain consistency with the prior knowledge or constraints. This approach is widely used in adaptive control and system identification to handle parameter uncertainties and ensure robust performance.</p> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Longsen Gao. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?b7816bd189846d29eded8745f9c4cf77"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>